        lw      0       2       mcand           # Load inputs
        lw      0       3       mplier
        lw      0       6       mulAdr          # Load mulIni's addr
        jalr    6       7                       # CALL FN | Jump to mul, saving the return addr to $7
        noop                                    # Placeholder lol
done    halt

mulIni  lw      0       6       maxItr          # Start of multiplication algorithm
        lw      0       4       one
        

mul     nand    4       3       5               # Check bits, starting from msb to lsb
        nand    5       5       5
        beq     5       0       1               # Check the condition if the msb is 1                     
        add     2       1       1               # UPDATE LOOP | increment here
        add     2       2       2               # Temp mcand
        add     4       4       4               # Check the next bit of mplier
        beq     4       6       1               # Go to jalr below once it is the 32nd iteration
        beq     0       0       mul             # Go back to the loop otherwise
        jalr    7       0                       # Return the final value, using $0 here means we are not going to save a return addr

mulAdr  .fill   mulIni                          # Multiplier addr
mcand   .fill   32766
mplier  .fill   10383
maxItr  .fill   -2147483648                              # A limit of how many iterations is allowed (we use the msb as the limit)
one     .fill   1                               # For $4 and lsb check before shifting to the right
